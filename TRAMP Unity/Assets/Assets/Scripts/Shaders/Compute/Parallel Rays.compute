// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//#include "/MarchingTables.compute"

static const int triTable[288] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 0
     0,  1,  4, -1, -1, -1, -1, -1, -1,   // 1
     4,  8,  5, -1, -1, -1, -1, -1, -1,   // 2
     0,  1,  5,  1,  8,  5, -1, -1, -1,   // 3
     0,  5,  2, -1, -1, -1, -1, -1, -1,   // 4
     4,  5,  1,  2,  1,  5, -1, -1, -1,   // 5
     0,  4,  8,  0,  8,  2, -1, -1, -1,   // 6
     1,  8,  2, -1, -1, -1, -1, -1, -1,   // 7
     1,  6,  3, -1, -1, -1, -1, -1, -1,   // 8
     0,  4,  6,  0,  6,  3, -1, -1, -1,   // 9
     1,  6,  2,  2,  6,  7, -1, -1, -1,   // 10
     2,  6,  7,  2,  4,  6,  0,  4,  2,   // 11
     1,  6,  3,  0,  5,  2, -1, -1, -1,   // 12
     2,  6,  7,  2,  4,  6,  0,  4,  2,   // 13
     0,  4,  2,  2,  4,  8,  1,  6,  3,   // 14
     0,  5,  2,  6,  8,  7, -1, -1, -1,   // 15
     6,  8,  7, -1, -1, -1, -1, -1, -1,   // 16
     6,  8,  7,  0,  1,  4, -1, -1, -1,   // 17
     4,  6,  5,  5,  6,  7, -1, -1, -1,   // 18
     1,  6,  7,  1,  5,  0,  5,  1,  6,   // 19
     0,  5,  2,  6,  8,  7, -1, -1, -1,   // 20
     4,  5,  1,  2,  1,  5,  6,  8,  7,   // 21
     0,  4,  6,  0,  6,  2,  6,  7,  2,   // 22
     1,  6,  2,  2,  6,  7, -1, -1, -1,   // 23
     1,  8,  7,  1,  7,  3, -1, -1, -1,   // 24
     0,  4,  8,  8,  7,  3,  0,  8,  3,   // 25
     4,  5,  1,  1,  5,  3,  3,  5,  7,   // 26
     0,  5,  3,  3,  8,  7, -1, -1, -1,   // 27
     1,  8,  7,  1,  7,  3,  0,  5,  2,   // 28
     4,  8,  5,  2,  3,  7, -1, -1, -1,   // 29
     0,  1,  4,  2,  3,  7, -1, -1, -1,   // 30
     2,  3,  7, -1, -1, -1, -1, -1, -1    // 31
    };

static const int edgeTable[18] = {
    0, 2, // 0
    0, 3, // 1
    5, 2, // 2
    3, 5, // 3
    0, 1, // 4
    1, 2, // 5
    3, 4, // 6
    4, 5, // 7
    1, 4  // 8
    };

struct Vertex {
    float3 pos;
    float3 norm;
    float4 color;
    float2 uv0;
};

float Time;
float Isolevel;
int Settings;
int Case;
int Depth;
float lerpSpeed;
float3 offset;

RWStructuredBuffer<uint> IndexBuffer;
RWStructuredBuffer<Vertex> VertexBuffer;
RWStructuredBuffer<Vertex> rays;
RWStructuredBuffer<uint> raysIndexes;

float Sample (float3 pos, float time) {
    float x = pos.x + offset.x;
    float y = pos.y + offset.y;
    float z = pos.z + offset.z;
    float d = sqrt(x * x + y * y + z * z);
    return sin(d) + sin(x) - sin(y) - y;
}


float3 interpolateVertex(uint lookup, float3 ps[6], float ws[6]) {
    
    int edge = triTable[lookup];
    if (edge != -1) {
        float3 p1 = ps[edgeTable[edge * 2]];
        float3 p2 = ps[edgeTable[edge * 2 + 1]];
        float t = 0.5; //sin(Time) * sin(Time) * 0.5 + cos(Time) * cos(Time) * ((Isolevel - ws[edgeTable[edge * 2]]) / (ws[edgeTable[edge * 2 + 1]] - ws[edgeTable[edge * 2]]));
        float3 p3 = p1 + t * (p2 - p1);

        return p3;
    } else {
        return ps[0];
    }
}

float3 calculateFaceNormals(float3 p1, float3 p2, float3 p3) {
    float3 A = p2 - p1;
    float3 B = p3 - p1;
    float3 N = float3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);
    return normalize(N);
}


[numthreads(32,1,1)]
void CSMain (uint id : SV_DispatchThreadID) {
    
    uint vOffset = id.x * 3;
    float3 v1 = normalize(rays[raysIndexes[vOffset]].pos);
    float3 v2 = normalize(rays[raysIndexes[vOffset + 1]].pos);
    float3 v3 = normalize(rays[raysIndexes[vOffset + 2]].pos);
    vOffset *= 3 * Depth;

    float3 samplePoints[6] = {
        (v1 * 0),
        (v2 * 0),
        (v3 * 0),
        (v1 * 0.05),
        (v2 * 0.05),
        (v3 * 0.05)
        };
    float ws[6] = {
        Isolevel, 
        Isolevel, 
        Isolevel, 
        Sample(samplePoints[0], Time), 
        Sample(samplePoints[1], Time), 
        Sample(samplePoints[2], Time), 
    };

    uint lookup = 0;
    if (ws[3] > Isolevel) lookup |= 8;
    if (ws[4] > Isolevel) lookup |= 16;
    if (ws[5] > Isolevel) lookup |= 32;

    for(int i = 0; i < Depth; i++) {
        if((ws[0] > Isolevel) & lookup != lookup) lookup = !lookup & 63;
        lookup >> 3;
        samplePoints[0] = float3(samplePoints[3].x, samplePoints[3].y, samplePoints[3].z);
        samplePoints[1] = float3(samplePoints[4].x, samplePoints[4].y, samplePoints[4].z);
        samplePoints[2] = float3(samplePoints[5].x, samplePoints[5].y, samplePoints[5].z);
        samplePoints[3] = v1 * (i + 1);
        samplePoints[4] = v2 * (i + 1);
        samplePoints[5] = v3 * (i + 1);
        ws[0] = ws[3];
        ws[1] = ws[4];
        ws[2] = ws[5];
        ws[3] = Sample(samplePoints[3], Time);
        ws[4] = Sample(samplePoints[4], Time);
        ws[5] = Sample(samplePoints[5], Time);
        if(ws[3] > Isolevel) lookup |= 8;
        if(ws[4] > Isolevel) lookup |= 16;
        if(ws[5] > Isolevel) lookup |= 32;
        if (lookup > 31) lookup = !lookup & 63;
        if (Case != 0) lookup = Case;
        lookup *= 9;
        VertexBuffer[0 + i * 9 + vOffset].pos -= (VertexBuffer[0 + i * 9 + vOffset].pos - interpolateVertex(lookup,  samplePoints, ws)) * lerpSpeed;
        VertexBuffer[1 + i * 9 + vOffset].pos -= (VertexBuffer[1 + i * 9 + vOffset].pos - interpolateVertex(lookup + 2, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[2 + i * 9 + vOffset].pos -= (VertexBuffer[2 + i * 9 + vOffset].pos - interpolateVertex(lookup + 1, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[3 + i * 9 + vOffset].pos -= (VertexBuffer[3 + i * 9 + vOffset].pos - interpolateVertex(lookup + 3, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[4 + i * 9 + vOffset].pos -= (VertexBuffer[4 + i * 9 + vOffset].pos - interpolateVertex(lookup + 5, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[5 + i * 9 + vOffset].pos -= (VertexBuffer[5 + i * 9 + vOffset].pos - interpolateVertex(lookup + 4, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[6 + i * 9 + vOffset].pos -= (VertexBuffer[6 + i * 9 + vOffset].pos - interpolateVertex(lookup + 6, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[7 + i * 9 + vOffset].pos -= (VertexBuffer[7 + i * 9 + vOffset].pos - interpolateVertex(lookup + 8, samplePoints, ws)) * lerpSpeed;
        VertexBuffer[8 + i * 9 + vOffset].pos -= (VertexBuffer[8 + i * 9 + vOffset].pos - interpolateVertex(lookup + 7, samplePoints, ws)) * lerpSpeed;
        float3 normal1 = calculateFaceNormals(VertexBuffer[0 + i * 9 + vOffset].pos, VertexBuffer[1 + i * 9 + vOffset].pos, VertexBuffer[2 + i * 9 + vOffset].pos);
        VertexBuffer[0 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[0] * ((Settings & 4) >> 2));
        VertexBuffer[1 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[2 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[1] * ((Settings & 4) >> 2));
        normal1 = calculateFaceNormals(VertexBuffer[3 + i * 9 + vOffset].pos, VertexBuffer[4 + i * 9 + vOffset].pos, VertexBuffer[5 + i * 9 + vOffset].pos);
        VertexBuffer[3 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[2] * ((Settings & 4) >> 2));
        VertexBuffer[4 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[5 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[3] * ((Settings & 4) >> 2));
        normal1 = calculateFaceNormals(VertexBuffer[6 + i * 9 + vOffset].pos, VertexBuffer[7 + i * 9 + vOffset].pos, VertexBuffer[8 + i * 9 + vOffset].pos);
        VertexBuffer[6 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[4] * ((Settings & 4) >> 2));
        VertexBuffer[7 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[8 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[5] * ((Settings & 4) >> 2));
        lookup /= 9;
        //if((lookup == 7) && ((Settings & 2) == 2)) {v1 = float3(0, 1, 0); v2 = v1; v3 = v1; samplePoints[3] = v1; samplePoints[4] = v1; samplePoints[5] = v1;}
    }
}