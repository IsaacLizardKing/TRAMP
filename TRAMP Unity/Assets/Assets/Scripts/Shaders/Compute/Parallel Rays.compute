// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//#include "/MarchingTables.compute"

static const int triTable[297] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 0
     0,  1,  4, -1, -1, -1, -1, -1, -1,   // 1
     4,  8,  5, -1, -1, -1, -1, -1, -1,   // 2
     0,  1,  5,  1,  8,  5, -1, -1, -1,   // 3
     0,  5,  2, -1, -1, -1, -1, -1, -1,   // 4
     4,  5,  1,  2,  1,  5, -1, -1, -1,   // 5
     0,  4,  8,  0,  8,  2, -1, -1, -1,   // 6
     1,  8,  2, -1, -1, -1, -1, -1, -1,   // 7
     1,  6,  3, -1, -1, -1, -1, -1, -1,   // 8
     0,  4,  6,  0,  6,  3, -1, -1, -1,   // 9
     1,  6,  3,  4,  5,  8, -1, -1, -1,   // 10
     0,  5,  3,  5,  8,  3,  6,  3,  8,   // 11
     1,  6,  3,  0,  2,  5, -1, -1, -1,   // 12
     2,  4,  6,  2,  6,  3,  5,  4,  2,   // 13
     0,  2,  4,  2,  8,  4,  1,  6,  3,   // 14
     2,  8,  3,  6,  3,  8, -1, -1, -1,   // 15
     6,  8,  7, -1, -1, -1, -1, -1, -1,   // 16
     6,  8,  7,  0,  4,  1, -1, -1, -1,   // 17
     4,  5,  6,  5,  7,  6, -1, -1, -1,   // 18
     5,  7,  6,  1,  0,  5,  5,  6,  1,   // 19
     0,  2,  5,  6,  8,  7, -1, -1, -1,   // 20
     4,  1,  5,  2,  5,  1,  6,  8,  7,   // 21
     0,  6,  4,  0,  2,  6,  6,  2,  7,   // 22
     1,  2,  6,  2,  7,  6, -1, -1, -1,   // 23
     1,  8,  7,  1,  7,  3, -1, -1, -1,   // 24
     0,  4,  8,  8,  7,  3,  0,  8,  3,   // 25
     4,  5,  1,  1,  5,  3,  3,  5,  7,   // 26
     0,  5,  3,  5,  7,  3, -1, -1, -1,   // 27
     1,  8,  7,  1,  7,  3,  0,  2,  5,   // 28
     4,  8,  5,  2,  7,  3, -1, -1, -1,   // 29
     0,  1,  4,  2,  7,  3, -1, -1, -1,   // 30
     2,  7,  3, -1, -1, -1, -1, -1, -1,   // 31
     2,  3,  7, -1, -1, -1, -1, -1, -1    // 32
    };


static const int edgeTable[18] = {
    0, 2, // 0
    0, 3, // 1
    5, 2, // 2
    3, 5, // 3
    0, 1, // 4
    1, 2, // 5
    3, 4, // 6
    4, 5, // 7
    1, 4  // 8
    };

struct Vertex {
    float3 pos;
    float3 norm;
    float4 color;
    float2 uv0;
};

float Time;
float Isolevel;
uint Settings;
uint Case;
int Depth;
float lerpSpeed;
float3 offset;
float4 rotation;

RWStructuredBuffer<uint> IndexBuffer;
RWStructuredBuffer<Vertex> VertexBuffer;
RWStructuredBuffer<Vertex> rays;
RWStructuredBuffer<uint> raysIndices;

float Sample (float3 pos, float time) {
    float x = pos.x + offset.x;
    float y = pos.y + offset.y;
    float z = pos.z + offset.z;
    float d = sqrt(x * x + y * y + z * z);
    //return (x * x + y * y - (sin(time) * sin(time))) + z * z;
    //return sin(x) * sin(y) * sin(z);
    //return sin(z) + y / 100 + sin(sqrt(d));
    return sin(d) - sin(y) + sin(z + cos(time) + time * 0.00000001) - x * 0.01;
    //return x * x * x * x - 5 * x * x + y * y * y * y - 5 * y * y + z * z * z * z - 5 * z * z + 10;
}

float Magnitude (float3 pos) {
    float x = pos.x;
    float y = pos.y;
    float z = pos.z;
    return sqrt(x * x + y * y + z * z);
}


float3 interpolateVertex(uint lookup, float3 ps[6], float ws[6]) {
    int edge = triTable[lookup];
    if (edge != -1) {
        float3 p1 = ps[edgeTable[edge * 2]];
        float3 p2 = ps[edgeTable[edge * 2 + 1]];
        float t = (~Settings & 1) * 0.5 + (Settings & 1) * ((Isolevel - ws[edgeTable[edge * 2]]) / (ws[edgeTable[edge * 2 + 1]] - ws[edgeTable[edge * 2]]));
        
        float3 p3 = p1 + max(0, min(1, t)) * (p2 - p1);

        return p3;
    } else {
        return ps[0];
    }
}

float3 calculateFaceNormals(float3 p1, float3 p2, float3 p3) {
    float3 A = p2 - p1;
    float3 B = p3 - p1;
    float3 N = float3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);
    return normalize(N);
}


float4 qmul(float4 q1, float4 q2){
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

float3 rotateVector(float3 v, float4 r){
    float4 r_c = r * float4(-1, -1, -1, 1);
    return qmul(r, qmul(float4(v, 0), r_c)).xyz;
}
//from http://mathworld.wolfram.com/Quaternion.html per elseforty


[numthreads(64,1,1)]
void CSMain (uint id : SV_DispatchThreadID) {
    uint vOffset = id.x * 3;
    uint a = raysIndices[vOffset];
    uint b = raysIndices[vOffset + 1];
    uint c = raysIndices[vOffset + 2];

    //uint d = max(a, b); uint e = min(a, b); a = e; b = d; d = max(b, c); e = min(b, c); c = d; e = b; d = max(a, b); e = min(a, b); a = e; b = d;
    
    float3 v1 = normalize(rays[a].pos);
    float3 v2 = normalize(rays[b].pos);
    float3 v3 = normalize(rays[c].pos);
    float3 sampleV1 = normalize(rotateVector(v1, rotation));
    float3 sampleV2 = normalize(rotateVector(v2, rotation));
    float3 sampleV3 = normalize(rotateVector(v3, rotation));
    vOffset *= 3 * Depth;
    
    // VertexBuffer[0 + vOffset].pos -= (VertexBuffer[0 + vOffset].pos - v1) * lerpSpeed;
    // VertexBuffer[1 + vOffset].pos -= (VertexBuffer[1 + vOffset].pos - v2) * lerpSpeed;
    // VertexBuffer[2 + vOffset].pos -= (VertexBuffer[2 + vOffset].pos - v3) * lerpSpeed;

    float3 samplePoints[6] = {
        (sampleV1 * 0),
        (sampleV2 * 0),
        (sampleV3 * 0),
        (sampleV1 * 0.1),
        (sampleV2 * 0.1),
        (sampleV3 * 0.1)
        };
    float3 interpPoints[6] = {
        (v1 * 0),
        (v2 * 0),
        (v3 * 0),
        (v1 * 0.1),
        (v2 * 0.1),
        (v3 * 0.1)
        };
    float ws[6] = {
        Isolevel, 
        Isolevel, 
        Isolevel, 
        Sample(samplePoints[0], Time), 
        Sample(samplePoints[1], Time), 
        Sample(samplePoints[2], Time), 
    };

    bool inside = Sample(offset, Time) > Isolevel;

    uint lookup = 0;
    if (ws[3] > Isolevel) lookup |= 8;
    if (ws[4] > Isolevel) lookup |= 16;
    if (ws[5] > Isolevel) lookup |= 32;

    for(int i = 0; i < Depth; i++) {
        lookup = lookup >> 3;
        bool inverted = false;
        samplePoints[0] = samplePoints[3];
        samplePoints[1] = samplePoints[4];
        samplePoints[2] = samplePoints[5];
        interpPoints[0] = interpPoints[3];
        interpPoints[1] = interpPoints[4];
        interpPoints[2] = interpPoints[5];
        float projectionDistance = Magnitude(samplePoints[0]) + 0.5;//(Magnitude(interpPoints[0] - interpPoints[1]) + Magnitude(interpPoints[1] - interpPoints[2]) + Magnitude(interpPoints[2] - interpPoints[0])) / 3;
        samplePoints[3] = sampleV1 * projectionDistance;
        samplePoints[4] = sampleV2 * projectionDistance;
        samplePoints[5] = sampleV3 * projectionDistance;
        interpPoints[3] = v1 * projectionDistance;
        interpPoints[4] = v2 * projectionDistance;
        interpPoints[5] = v3 * projectionDistance;
        ws[0] = Sample(samplePoints[0], Time);
        ws[1] = Sample(samplePoints[1], Time);
        ws[2] = Sample(samplePoints[2], Time);
        ws[3] = Sample(samplePoints[3], Time);
        ws[4] = Sample(samplePoints[4], Time);
        ws[5] = Sample(samplePoints[5], Time);
        
        if(ws[0] > Isolevel) lookup |= 1;
        if(ws[1] > Isolevel) lookup |= 2;
        if(ws[2] > Isolevel) lookup |= 4;
        if(ws[3] > Isolevel) lookup |= 8;
        if(ws[4] > Isolevel) lookup |= 16;
        if(ws[5] > Isolevel) lookup |= 32;
        if (lookup > 32) { lookup = 63 - lookup; inverted = true; }
        if (Case != 0) lookup = Case;
        lookup *= 9;
        VertexBuffer[0 + i * 9 + vOffset].pos -= (VertexBuffer[0 + i * 9 + vOffset].pos - interpolateVertex(lookup, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[1 + i * 9 + vOffset].pos -= (VertexBuffer[1 + i * 9 + vOffset].pos - interpolateVertex(lookup + 1, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[2 + i * 9 + vOffset].pos -= (VertexBuffer[2 + i * 9 + vOffset].pos - interpolateVertex(lookup + 2, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[3 + i * 9 + vOffset].pos -= (VertexBuffer[3 + i * 9 + vOffset].pos - interpolateVertex(lookup + 3, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[4 + i * 9 + vOffset].pos -= (VertexBuffer[4 + i * 9 + vOffset].pos - interpolateVertex(lookup + 4, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[5 + i * 9 + vOffset].pos -= (VertexBuffer[5 + i * 9 + vOffset].pos - interpolateVertex(lookup + 5, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[6 + i * 9 + vOffset].pos -= (VertexBuffer[6 + i * 9 + vOffset].pos - interpolateVertex(lookup + 6, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[7 + i * 9 + vOffset].pos -= (VertexBuffer[7 + i * 9 + vOffset].pos - interpolateVertex(lookup + 7, interpPoints, ws)) * lerpSpeed;
        VertexBuffer[8 + i * 9 + vOffset].pos -= (VertexBuffer[8 + i * 9 + vOffset].pos - interpolateVertex(lookup + 8, interpPoints, ws)) * lerpSpeed;
        float adj = 0.001;
        
        float3 xadj = float3(adj, 0, 0);
        float3 yadj = float3(0, adj, 0);
        float3 zadj = float3(0, 0, adj);
        bool InvertedYet = IndexBuffer[0 + i * 9 + vOffset] > IndexBuffer[1 + i * 9 + vOffset];
        if(((Settings & 8) == 8 && ((inside && !InvertedYet && !inverted) || (!inside && InvertedYet && !inverted) || (!inside && !InvertedYet && inverted)))) {
            uint a = IndexBuffer[0 + i * 9 + vOffset];
            IndexBuffer[0 + i * 9 + vOffset] = IndexBuffer[1 + i * 9 + vOffset];
            IndexBuffer[1 + i * 9 + vOffset] = a;
        }
        float3 center = (VertexBuffer[0 + i * 9 + vOffset].pos + VertexBuffer[1 + i * 9 + vOffset].pos + VertexBuffer[2 + i * 9 + vOffset].pos) / 3;
        float3 normal1 = calculateFaceNormals(VertexBuffer[IndexBuffer[0 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[1 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[2 + i * 9 + vOffset]].pos);
        if((Settings & 16) == 16 && Magnitude(center + normal1) > Magnitude(center - normal1)) {
            float a = IndexBuffer[0 + i * 9 + vOffset];
            IndexBuffer[0 + i * 9 + vOffset] = IndexBuffer[1 + i * 9 + vOffset];
            IndexBuffer[1 + i * 9 + vOffset] = a;
            normal1 = -normal1;
        }
        VertexBuffer[0 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[0] * ((Settings & 4) >> 2));
        VertexBuffer[1 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[2 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[1] * ((Settings & 4) >> 2));
        //VertexBuffer[0 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[0 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[0 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[0 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[0 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[0 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[0 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[0 + i * 9 + vOffset].norm + VertexBuffer[0 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[0 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[0 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[1 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[1 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[1 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[1 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[1 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[1 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[1 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[1 + i * 9 + vOffset].norm + VertexBuffer[1 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[1 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[1 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[2 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[2 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[2 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[2 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[2 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[2 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[2 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[2 + i * 9 + vOffset].norm + VertexBuffer[2 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[2 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[2 + i * 9 + vOffset].norm *= -1; }

        InvertedYet = IndexBuffer[3 + i * 9 + vOffset] > IndexBuffer[4 + i * 9 + vOffset];
        if(((Settings & 8) == 8 && ((inside && !InvertedYet && !inverted) || (!inside && InvertedYet && !inverted) || (!inside && !InvertedYet && inverted)))) {
            uint a = IndexBuffer[3 + i * 9 + vOffset];
            IndexBuffer[3 + i * 9 + vOffset] = IndexBuffer[4 + i * 9 + vOffset];
            IndexBuffer[4 + i * 9 + vOffset] = a;
        }
        center = (VertexBuffer[3 + i * 9 + vOffset].pos + VertexBuffer[4 + i * 9 + vOffset].pos + VertexBuffer[5 + i * 9 + vOffset].pos) / 3;
        normal1 = calculateFaceNormals(VertexBuffer[IndexBuffer[3 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[4 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[5 + i * 9 + vOffset]].pos);
        if((Settings & 16) == 16 && Magnitude(center + normal1) > Magnitude(center - normal1)) {
            float a = IndexBuffer[3 + i * 9 + vOffset];
            IndexBuffer[3 + i * 9 + vOffset] = IndexBuffer[4 + i * 9 + vOffset];
            IndexBuffer[4 + i * 9 + vOffset] = a;
            normal1 = -normal1;
        }
        VertexBuffer[3 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[0] * ((Settings & 4) >> 2));
        VertexBuffer[4 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[5 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[1] * ((Settings & 4) >> 2));

        //VertexBuffer[3 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[3 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[3 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[3 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[3 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[3 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[3 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[3 + i * 9 + vOffset].norm + VertexBuffer[3 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[3 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[3 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[4 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[4 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[4 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[4 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[4 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[4 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[4 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[4 + i * 9 + vOffset].norm + VertexBuffer[4 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[4 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[4 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[5 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[5 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[5 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[5 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[5 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[5 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[5 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[5 + i * 9 + vOffset].norm + VertexBuffer[5 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[5 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[5 + i * 9 + vOffset].norm *= -1; }
        InvertedYet = IndexBuffer[6 + i * 9 + vOffset] > IndexBuffer[7 + i * 9 + vOffset];
        if(((Settings & 8) == 8 && ((inside && !InvertedYet && !inverted) || (!inside && InvertedYet && !inverted) || (!inside && !InvertedYet && inverted)))) {
            float a = IndexBuffer[6 + i * 9 + vOffset];
            IndexBuffer[6 + i * 9 + vOffset] = IndexBuffer[7 + i * 9 + vOffset];
            IndexBuffer[7 + i * 9 + vOffset] = a;
        }
        center = (VertexBuffer[6 + i * 9 + vOffset].pos + VertexBuffer[7 + i * 9 + vOffset].pos + VertexBuffer[8 + i * 9 + vOffset].pos) / 3;
        normal1 = calculateFaceNormals(VertexBuffer[IndexBuffer[6 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[7 + i * 9 + vOffset]].pos, VertexBuffer[IndexBuffer[8 + i * 9 + vOffset]].pos);
        
        if((Settings & 16) == 16 && Magnitude(center + normal1) > Magnitude(center - normal1)) {
            float a = IndexBuffer[6 + i * 9 + vOffset];
            IndexBuffer[6 + i * 9 + vOffset] = IndexBuffer[7 + i * 9 + vOffset];
            IndexBuffer[7 + i * 9 + vOffset] = a;
            normal1 = -normal1;
        }
        VertexBuffer[6 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[0] * ((Settings & 4) >> 2));
        VertexBuffer[7 + i * 9 + vOffset].norm = normal1;
        VertexBuffer[8 + i * 9 + vOffset].norm = normalize(normal1 + samplePoints[1] * ((Settings & 4) >> 2));

        //VertexBuffer[6 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[6 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[6 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[6 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[6 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[6 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[6 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[6 + i * 9 + vOffset].norm + VertexBuffer[6 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[6 + i * 9 + vOffset].norm - VertexBuffer[6 + i * 9 + vOffset].pos)) { VertexBuffer[6 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[7 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[7 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[7 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[7 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[7 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[7 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[7 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[8 + i * 9 + vOffset].norm + VertexBuffer[7 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[7 + i * 9 + vOffset].norm - VertexBuffer[7 + i * 9 + vOffset].pos)) { VertexBuffer[7 + i * 9 + vOffset].norm *= -1; }
        //VertexBuffer[8 + i * 9 + vOffset].norm = normalize(float3((Sample(VertexBuffer[8 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[8 + i * 9 + vOffset].pos + xadj, Time)) / adj, (Sample(VertexBuffer[8 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[8 + i * 9 + vOffset].pos + yadj, Time)) / adj, (Sample(VertexBuffer[8 + i * 9 + vOffset].pos, Time) - Sample(VertexBuffer[8 + i * 9 + vOffset].pos + zadj, Time)) / adj));
        //if (Magnitude(VertexBuffer[7 + i * 9 + vOffset].norm + VertexBuffer[8 + i * 9 + vOffset].pos) > Magnitude(VertexBuffer[8 + i * 9 + vOffset].norm - VertexBuffer[8 + i * 9 + vOffset].pos)) { VertexBuffer[8 + i * 9 + vOffset].norm *= -1; }
        lookup /= 9;
        if(inverted) { lookup = !lookup & 63; }
        //if((lookup == 7) && ((Settings & 2) == 2)) {v1 = float3(0, 1, 0); v2 = v1; v3 = v1; samplePoints[3] = v1; samplePoints[4] = v1; samplePoints[5] = v1;}
    }
}